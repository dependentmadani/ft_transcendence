(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('universal-cookie'), require('react')) :
	typeof define === 'function' && define.amd ? define(['universal-cookie', 'react'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactCookie = factory(global.UniversalCookie, global.React));
})(this, (function (require$$0, require$$0$1) { 'use strict';

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var cjs = {};

	var Cookies = {exports: {}};

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports["default"] = void 0;
		var _universalCookie = _interopRequireDefault(require$$0);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		var _default = _universalCookie["default"];
		exports["default"] = _default;
		module.exports = exports.default; 
	} (Cookies, Cookies.exports));

	var CookiesExports = Cookies.exports;

	var CookiesProvider = {exports: {}};

	var CookiesContext = {};

	(function (exports) {

		function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports["default"] = exports.Provider = exports.Consumer = void 0;
		var React = _interopRequireWildcard(require$$0$1);
		var _Cookies = _interopRequireDefault(CookiesExports);
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
		function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
		var CookiesContext = /*#__PURE__*/React.createContext(new _Cookies["default"]());
		var Provider = CookiesContext.Provider,
		  Consumer = CookiesContext.Consumer;
		exports.Consumer = Consumer;
		exports.Provider = Provider;
		var _default = CookiesContext;
		exports["default"] = _default; 
	} (CookiesContext));

	(function (module, exports) {

		function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports["default"] = void 0;
		var React = _interopRequireWildcard(require$$0$1);
		var _universalCookie = _interopRequireDefault(require$$0);
		var _CookiesContext = CookiesContext;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
		function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
		function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
		function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
		function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
		function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
		function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
		var CookiesProvider = /*#__PURE__*/function (_React$Component) {
		  _inherits(CookiesProvider, _React$Component);
		  var _super = _createSuper(CookiesProvider);
		  function CookiesProvider(props) {
		    var _this;
		    _classCallCheck(this, CookiesProvider);
		    _this = _super.call(this, props);
		    if (props.cookies) {
		      _this.cookies = props.cookies;
		    } else {
		      _this.cookies = new _universalCookie["default"]();
		    }
		    return _this;
		  }
		  _createClass(CookiesProvider, [{
		    key: "render",
		    value: function render() {
		      return /*#__PURE__*/React.createElement(_CookiesContext.Provider, {
		        value: this.cookies
		      }, this.props.children);
		    }
		  }]);
		  return CookiesProvider;
		}(React.Component);
		exports["default"] = CookiesProvider;
		module.exports = exports.default; 
	} (CookiesProvider, CookiesProvider.exports));

	var CookiesProviderExports = CookiesProvider.exports;

	var withCookies = {exports: {}};

	var reactIs$1 = {exports: {}};

	var reactIs_development = {};

	/** @license React v16.13.1
	 * react-is.development.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactIs_development;

	function requireReactIs_development () {
		if (hasRequiredReactIs_development) return reactIs_development;
		hasRequiredReactIs_development = 1;



		{
		  (function() {

		// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
		// nor polyfill, then a plain number is used for performance.
		var hasSymbol = typeof Symbol === 'function' && Symbol.for;
		var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
		var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
		var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
		var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
		var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
		var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
		var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
		// (unstable) APIs that have been removed. Can we remove the symbols?

		var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
		var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
		var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
		var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
		var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
		var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
		var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
		var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
		var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
		var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
		var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

		function isValidElementType(type) {
		  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
		  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
		}

		function typeOf(object) {
		  if (typeof object === 'object' && object !== null) {
		    var $$typeof = object.$$typeof;

		    switch ($$typeof) {
		      case REACT_ELEMENT_TYPE:
		        var type = object.type;

		        switch (type) {
		          case REACT_ASYNC_MODE_TYPE:
		          case REACT_CONCURRENT_MODE_TYPE:
		          case REACT_FRAGMENT_TYPE:
		          case REACT_PROFILER_TYPE:
		          case REACT_STRICT_MODE_TYPE:
		          case REACT_SUSPENSE_TYPE:
		            return type;

		          default:
		            var $$typeofType = type && type.$$typeof;

		            switch ($$typeofType) {
		              case REACT_CONTEXT_TYPE:
		              case REACT_FORWARD_REF_TYPE:
		              case REACT_LAZY_TYPE:
		              case REACT_MEMO_TYPE:
		              case REACT_PROVIDER_TYPE:
		                return $$typeofType;

		              default:
		                return $$typeof;
		            }

		        }

		      case REACT_PORTAL_TYPE:
		        return $$typeof;
		    }
		  }

		  return undefined;
		} // AsyncMode is deprecated along with isAsyncMode

		var AsyncMode = REACT_ASYNC_MODE_TYPE;
		var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
		var ContextConsumer = REACT_CONTEXT_TYPE;
		var ContextProvider = REACT_PROVIDER_TYPE;
		var Element = REACT_ELEMENT_TYPE;
		var ForwardRef = REACT_FORWARD_REF_TYPE;
		var Fragment = REACT_FRAGMENT_TYPE;
		var Lazy = REACT_LAZY_TYPE;
		var Memo = REACT_MEMO_TYPE;
		var Portal = REACT_PORTAL_TYPE;
		var Profiler = REACT_PROFILER_TYPE;
		var StrictMode = REACT_STRICT_MODE_TYPE;
		var Suspense = REACT_SUSPENSE_TYPE;
		var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

		function isAsyncMode(object) {
		  {
		    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
		      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

		      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
		    }
		  }

		  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
		}
		function isConcurrentMode(object) {
		  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
		}
		function isContextConsumer(object) {
		  return typeOf(object) === REACT_CONTEXT_TYPE;
		}
		function isContextProvider(object) {
		  return typeOf(object) === REACT_PROVIDER_TYPE;
		}
		function isElement(object) {
		  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		}
		function isForwardRef(object) {
		  return typeOf(object) === REACT_FORWARD_REF_TYPE;
		}
		function isFragment(object) {
		  return typeOf(object) === REACT_FRAGMENT_TYPE;
		}
		function isLazy(object) {
		  return typeOf(object) === REACT_LAZY_TYPE;
		}
		function isMemo(object) {
		  return typeOf(object) === REACT_MEMO_TYPE;
		}
		function isPortal(object) {
		  return typeOf(object) === REACT_PORTAL_TYPE;
		}
		function isProfiler(object) {
		  return typeOf(object) === REACT_PROFILER_TYPE;
		}
		function isStrictMode(object) {
		  return typeOf(object) === REACT_STRICT_MODE_TYPE;
		}
		function isSuspense(object) {
		  return typeOf(object) === REACT_SUSPENSE_TYPE;
		}

		reactIs_development.AsyncMode = AsyncMode;
		reactIs_development.ConcurrentMode = ConcurrentMode;
		reactIs_development.ContextConsumer = ContextConsumer;
		reactIs_development.ContextProvider = ContextProvider;
		reactIs_development.Element = Element;
		reactIs_development.ForwardRef = ForwardRef;
		reactIs_development.Fragment = Fragment;
		reactIs_development.Lazy = Lazy;
		reactIs_development.Memo = Memo;
		reactIs_development.Portal = Portal;
		reactIs_development.Profiler = Profiler;
		reactIs_development.StrictMode = StrictMode;
		reactIs_development.Suspense = Suspense;
		reactIs_development.isAsyncMode = isAsyncMode;
		reactIs_development.isConcurrentMode = isConcurrentMode;
		reactIs_development.isContextConsumer = isContextConsumer;
		reactIs_development.isContextProvider = isContextProvider;
		reactIs_development.isElement = isElement;
		reactIs_development.isForwardRef = isForwardRef;
		reactIs_development.isFragment = isFragment;
		reactIs_development.isLazy = isLazy;
		reactIs_development.isMemo = isMemo;
		reactIs_development.isPortal = isPortal;
		reactIs_development.isProfiler = isProfiler;
		reactIs_development.isStrictMode = isStrictMode;
		reactIs_development.isSuspense = isSuspense;
		reactIs_development.isValidElementType = isValidElementType;
		reactIs_development.typeOf = typeOf;
		  })();
		}
		return reactIs_development;
	}

	{
	  reactIs$1.exports = requireReactIs_development();
	}

	var reactIsExports = reactIs$1.exports;

	var reactIs = reactIsExports;

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	var REACT_STATICS = {
	  childContextTypes: true,
	  contextType: true,
	  contextTypes: true,
	  defaultProps: true,
	  displayName: true,
	  getDefaultProps: true,
	  getDerivedStateFromError: true,
	  getDerivedStateFromProps: true,
	  mixins: true,
	  propTypes: true,
	  type: true
	};
	var KNOWN_STATICS = {
	  name: true,
	  length: true,
	  prototype: true,
	  caller: true,
	  callee: true,
	  arguments: true,
	  arity: true
	};
	var FORWARD_REF_STATICS = {
	  '$$typeof': true,
	  render: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true
	};
	var MEMO_STATICS = {
	  '$$typeof': true,
	  compare: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true,
	  type: true
	};
	var TYPE_STATICS = {};
	TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
	TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

	function getStatics(component) {
	  // React v16.11 and below
	  if (reactIs.isMemo(component)) {
	    return MEMO_STATICS;
	  } // React v16.12 and above


	  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
	}

	var defineProperty = Object.defineProperty;
	var getOwnPropertyNames = Object.getOwnPropertyNames;
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var getPrototypeOf = Object.getPrototypeOf;
	var objectPrototype = Object.prototype;
	function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
	  if (typeof sourceComponent !== 'string') {
	    // don't hoist over string (html) components
	    if (objectPrototype) {
	      var inheritedComponent = getPrototypeOf(sourceComponent);

	      if (inheritedComponent && inheritedComponent !== objectPrototype) {
	        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
	      }
	    }

	    var keys = getOwnPropertyNames(sourceComponent);

	    if (getOwnPropertySymbols) {
	      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
	    }

	    var targetStatics = getStatics(targetComponent);
	    var sourceStatics = getStatics(sourceComponent);

	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i];

	      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
	        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

	        try {
	          // Avoid failures from read-only properties
	          defineProperty(targetComponent, key, descriptor);
	        } catch (e) {}
	      }
	    }
	  }

	  return targetComponent;
	}

	var hoistNonReactStatics_cjs = hoistNonReactStatics;

	(function (module, exports) {

		function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports["default"] = withCookies;
		var React = _interopRequireWildcard(require$$0$1);
		var _hoistNonReactStatics = _interopRequireDefault(hoistNonReactStatics_cjs);
		var _CookiesContext = CookiesContext;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
		function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
		function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
		function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
		function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
		function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
		function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
		function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
		function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
		var __rest = function (s, e) {
		  var t = {};
		  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
		  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
		    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
		  }
		  return t;
		};
		function withCookies(WrappedComponent) {
		  // @ts-ignore
		  var name = WrappedComponent.displayName || WrappedComponent.name;
		  var CookieWrapper = /*#__PURE__*/function (_React$Component) {
		    _inherits(CookieWrapper, _React$Component);
		    var _super = _createSuper(CookieWrapper);
		    function CookieWrapper() {
		      var _this;
		      _classCallCheck(this, CookieWrapper);
		      _this = _super.apply(this, arguments);
		      _this.onChange = function () {
		        // Make sure to update children with new values
		        _this.forceUpdate();
		      };
		      return _this;
		    }
		    _createClass(CookieWrapper, [{
		      key: "listen",
		      value: function listen() {
		        this.props.cookies.addChangeListener(this.onChange);
		      }
		    }, {
		      key: "unlisten",
		      value: function unlisten(cookies) {
		        (cookies || this.props.cookies).removeChangeListener(this.onChange);
		      }
		    }, {
		      key: "componentDidMount",
		      value: function componentDidMount() {
		        this.listen();
		      }
		    }, {
		      key: "componentDidUpdate",
		      value: function componentDidUpdate(prevProps) {
		        if (prevProps.cookies !== this.props.cookies) {
		          this.unlisten(prevProps.cookies);
		          this.listen();
		        }
		      }
		    }, {
		      key: "componentWillUnmount",
		      value: function componentWillUnmount() {
		        this.unlisten();
		      }
		    }, {
		      key: "render",
		      value: function render() {
		        var _a = this.props,
		          forwardedRef = _a.forwardedRef,
		          cookies = _a.cookies,
		          restProps = __rest(_a, ["forwardedRef", "cookies"]);
		        var allCookies = cookies.getAll();
		        return /*#__PURE__*/React.createElement(WrappedComponent, Object.assign({}, restProps, {
		          ref: forwardedRef,
		          cookies: cookies,
		          allCookies: allCookies
		        }));
		      }
		    }]);
		    return CookieWrapper;
		  }(React.Component);
		  CookieWrapper.displayName = "withCookies(".concat(name, ")");
		  CookieWrapper.WrappedComponent = WrappedComponent;
		  var ForwardedComponent = /*#__PURE__*/React.forwardRef(function (props, ref) {
		    return /*#__PURE__*/React.createElement(_CookiesContext.Consumer, null, function (cookies) {
		      return /*#__PURE__*/React.createElement(CookieWrapper, Object.assign({
		        cookies: cookies
		      }, props, {
		        forwardedRef: ref
		      }));
		    });
		  });
		  ForwardedComponent.displayName = CookieWrapper.displayName;
		  ForwardedComponent.WrappedComponent = CookieWrapper.WrappedComponent;
		  return (0, _hoistNonReactStatics["default"])(ForwardedComponent, WrappedComponent);
		}
		module.exports = exports.default; 
	} (withCookies, withCookies.exports));

	var withCookiesExports = withCookies.exports;

	var useCookies = {exports: {}};

	var utils = {};

	Object.defineProperty(utils, "__esModule", {
	  value: true
	});
	utils.isInBrowser = isInBrowser;
	function isInBrowser() {
	  return typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
	}

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports["default"] = useCookies;
		var _react = require$$0$1;
		var _CookiesContext = _interopRequireDefault(CookiesContext);
		var _utils = utils;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
		function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
		function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
		function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
		function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
		function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
		function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
		function useCookies(dependencies) {
		  var cookies = (0, _react.useContext)(_CookiesContext["default"]);
		  if (!cookies) {
		    throw new Error('Missing <CookiesProvider>');
		  }
		  var initialCookies = cookies.getAll();
		  var _useState = (0, _react.useState)(initialCookies),
		    _useState2 = _slicedToArray(_useState, 2),
		    allCookies = _useState2[0],
		    setCookies = _useState2[1];
		  var previousCookiesRef = (0, _react.useRef)(allCookies);
		  if ((0, _utils.isInBrowser)()) {
		    (0, _react.useLayoutEffect)(function () {
		      function onChange() {
		        var newCookies = cookies.getAll();
		        if (shouldUpdate(dependencies || null, newCookies, previousCookiesRef.current)) {
		          setCookies(newCookies);
		        }
		        previousCookiesRef.current = newCookies;
		      }
		      cookies.addChangeListener(onChange);
		      return function () {
		        cookies.removeChangeListener(onChange);
		      };
		    }, [cookies]);
		  }
		  var setCookie = (0, _react.useMemo)(function () {
		    return cookies.set.bind(cookies);
		  }, [cookies]);
		  var removeCookie = (0, _react.useMemo)(function () {
		    return cookies.remove.bind(cookies);
		  }, [cookies]);
		  return [allCookies, setCookie, removeCookie];
		}
		function shouldUpdate(dependencies, newCookies, oldCookies) {
		  if (!dependencies) {
		    return true;
		  }
		  var _iterator = _createForOfIteratorHelper(dependencies),
		    _step;
		  try {
		    for (_iterator.s(); !(_step = _iterator.n()).done;) {
		      var dependency = _step.value;
		      if (newCookies[dependency] !== oldCookies[dependency]) {
		        return true;
		      }
		    }
		  } catch (err) {
		    _iterator.e(err);
		  } finally {
		    _iterator.f();
		  }
		  return false;
		}
		module.exports = exports.default; 
	} (useCookies, useCookies.exports));

	var useCookiesExports = useCookies.exports;

	var types = {};

	Object.defineProperty(types, "__esModule", {
	  value: true
	});

	(function (exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		var _exportNames = {
		  Cookies: true,
		  CookiesProvider: true,
		  withCookies: true,
		  useCookies: true
		};
		Object.defineProperty(exports, "Cookies", {
		  enumerable: true,
		  get: function get() {
		    return _Cookies["default"];
		  }
		});
		Object.defineProperty(exports, "CookiesProvider", {
		  enumerable: true,
		  get: function get() {
		    return _CookiesProvider["default"];
		  }
		});
		Object.defineProperty(exports, "useCookies", {
		  enumerable: true,
		  get: function get() {
		    return _useCookies["default"];
		  }
		});
		Object.defineProperty(exports, "withCookies", {
		  enumerable: true,
		  get: function get() {
		    return _withCookies["default"];
		  }
		});
		var _Cookies = _interopRequireDefault(CookiesExports);
		var _CookiesProvider = _interopRequireDefault(CookiesProviderExports);
		var _withCookies = _interopRequireDefault(withCookiesExports);
		var _useCookies = _interopRequireDefault(useCookiesExports);
		var _types = types;
		Object.keys(_types).forEach(function (key) {
		  if (key === "default" || key === "__esModule") return;
		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
		  if (key in exports && exports[key] === _types[key]) return;
		  Object.defineProperty(exports, key, {
		    enumerable: true,
		    get: function get() {
		      return _types[key];
		    }
		  });
		});
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; } 
	} (cjs));

	var index = /*@__PURE__*/getDefaultExportFromCjs(cjs);

	return index;

}));
